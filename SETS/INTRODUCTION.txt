SETS::::
- Associative container -> elements ko sorted order mai store karta hai...
- Unique elements -> Do baar 1 nhi hoga...
- By default, ascending order mai store hota hai...
- #include<set> -> header file needed...
- Cannot be indexed... s[1] ❌  
- Cannot be modified once fixed...❌ as it may unfollow balance search tree props...
- Internally, stores in "red-black" tree...thus sorted...

SYNTAX::
- set <dtype, comp> name; 
- dtype, name -> mandatory 
- comp -> optional 

COMPLEXITIES::
- Finding smallest/largest element - O(1)  {ordered - first and last element}
- Traversing - O(n)   {looping}
- Finding any element / Inserting / Deleting - O(log n)  {Binary search}

SET VS UNORDERED SET::
- SET -> sorted order        
  UNORDERED SET -> unsorted order
- SET -> Insertions, deletions, and accessing operations takes O(log n) complexity...
  UNSORTED SET -> Insertion, deletion, and access operations are O(1) time due to the use of hashing.  

OPERATIONS::
- .insert(2) / .emplace(2) -> inserting new element...
- .begin() -> iterator pointing at beginning of set...
- .end() -> iterator pointing at end of set...
- auto it = next(iterator,no of gaps) -> wo particular value access karne ke liye...
- advance(iterator,no of gaps) -> wo particular value access karne ke liye...
- .find(3) -> if found returns an iterator pointing at 3 else points at .end()...
- .erase(3/it1) -> removes that element...
- .empty() -> checks if set is empty or not...returns true/false
- .size() -> no of elements...empty h then size is 0...
- .clear() -> deletes all elements... 

INTIALIZING::
- set<int>s = {1,2,3}
- set<int>s; s.insert(5);....etc 
- set<int>s = s1; 
- set<int>s(first,last);   first => iterator to first element    second => iterator to second element...

INSERTING::
- s.insert(3)
- s.insert({3,4,5,6})
- s.emplace(4) 
- auto it = next(it1,gaps)...it will point at that...
- advance(it1,gaps)...it1 will point at that...

DELETION::
- s.erase(4)
- s.erase(iterator)
- s.clear() 
- s.empty() -> to check  

FINDING::
- s.find(4)  returns an iterator pointing to that else .end() 


MASTERCLASS:::
1.  set <int> s = {3,5,2,1}; 
    for(auto x : s){
        cout<<x<<" ";
    }  
 -> How does "auto" helps us here???
    "Auto" automatically deduces type of elements in 's'...
    Each element of 's' is assigned to 'x' and is printed with the help of loop... 

2.  struct comp{
    bool operator() (int a, int b) const{
        return a > b;
      }
    };
    set<int,comp>s1; 
    s1.insert(3);
    s1.insert(5);
    s1.insert(1);

 -> "comp" is a custom dtype -> thus defined by struct/class...ye batata h ki do elements ko kaise compare karke...container mai store kiya jay...
 -> Yaha pe "()" operator overloaded hai...to jaise hi mai .insert() pass karta hu...automatic wo function call hojata hai...
 -> Initially, s1 khali tha...ek element aaya tab call nhi hua...second element aate hi call hua...
 -> a = new element      b = old element  
 -> True - a is ahead of b 
 -> False - a is behind of b 
 -> eg. s1 mai 3 hai...5 aaya...a = 5...b = 3...a > b...true...a is ahead of b store hoga...5 3...
        fir 1 aaya...a = 1...b = 5...a > b...false...1 is behind 5...
        a = 1...b = 3...a > b...false...1 is behind 3 as well...
        thus 5 3 1...
 -> "const" keyword is used taki comparating function sab elements ke liye same ho and wo bich modify na kiya ja sake...

